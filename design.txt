---20多天没看代码,基本上看不懂了. 为了防止思路丢失,尤其是防止忘记开始的设计走了弯路.还是有必要好把整体的设计做记录

1- dci设计模式

整个程序的功能结构分为数据,交易和订单,面向交易策略的其他服务
为了方便的略的编写,提供一个facade模式

所有这些动能集中在quant.h 中, 并且可以根据需要cast成不同的上下文:datacontext,mgmtcontxt,context

data和order mgmt通过delegate指向ctpdata(通过工厂类)
并且通过datacontext和mgmtcontext对外提供服务(主动调用context函数)


===>
quant 继承了 context，组合了omgmt来实现订单管理（真正实现了context的接口）


2- 指标系统的设计
aspect indicator  series 

每个aspect都必须以某个k线为基准,包含多个indicator
每个indicator下面有多个series,相当于一个指标有多个值,每个series使用一个循环数组保存,数组内的元素是element_t


3- 时钟和校准



4- 总线消息服务
reactor.h reactor_impl.h

总线用于对上层的应用模块提供支持,包括io(启动参数,控制命令,界面等, 也可以是内部提供上层服务)
n-n的通信模式,任何模块都可以pub或者sub消息,消息类型最好是统一的(msg.h)


其他
任务和内存池

---------------------------------





--数据设计---


两个层次，ctp层和通用数据层，希望ctp可以随时被替换,ctp回调中可以调用MARET.pub接口发送数据
从外部来的指令可以通过maret.on_msg_received收到，然后下发给ctp
这里的问题在于: 如何保证maret.pub 是单线程的，而且不会变更
：
这里好像不是很重要，zmq不支持多线程，但是并不意味着zmq::socket 不可以在多个线程中转移


zmq 使用的一些基本原则：
进程开始时创建一个ZeroMQ context, 并把它传递给你将用inproc套接字关联的所有线程。
使用 attached 线程在应用中构建结构, 并用 inproc PAIR 套接字连到父线程上。 这个模式是绑定父套接字, 然后创建会连接它的套接字子线程。
使用 detached 线程模拟独立任务, 带有自己的contexts。 用tcp连接它们。 以后你可以把这些转移到单独的进程而不需要修改很多代码。
线程间所有的交互都通过你自己多多少少正式定义的ZeroMQ消息实现。

---tips------
inproc套接字才共享 context
attched套接字使用inproc pair进行线程通信
detached 线程可以作为独立的进程拆分，所以要有自己的context
------------





-----------------------------------


---架构设计:
最开始的设计是有问题的,数据接受模块和交易模块和其他的模块，比如策略，订单管理，ui等是对等的
只不过数据和交易主要是pub，同时也接受 命令

但是考虑到不同的模块的处理速度和延迟不一样，这么做可能不合适

data     trader
 |          |
 |          |
 pub        pub
 |          |
 ----xpub---
 zmq_proxy
 ----xsub----
 |          |
 |          |
 sub        sub


 ---------------
 应该给data和和trader单独开4个通道
 2个pub和两个sub，或者req/..
 然后在reactor中集中的pub


 data     trader
 |          |
 |          |
 pub        pub
 |          |
 ----reactor---
        |
        pub------------------------上面的模式还是需要的，只是变成了架构的子模式
        |
        xsub/xpub
        |
    --------
 |          |
 |          |
 sub        sub
---
这种架构可以保证自己控制数据和交易的实时性，保证交易和数据的前提下再满足外部模块的订阅需求






--------
整个系统如果都是通过消息来驱动,就可以轻松的解耦

可以方便把数据暴露给新增模块的同时,我们自己整个系统的实现也可以通过这个机制来做
比如订单管理如果继续消息管理而不是回调的方式,依赖关系的解决就可以简单很多
不需要复杂的代码级别的设计

zmq的安装 
apt-get install libzmq3-dev



git clone git://github.com/zeromq/libzmq.git 
cd libzmq
./autogen.sh
./configure -with-libsodium && make 
sudo make install 
sudo ldconfig
cd ../



git clone https://github.com/zeromq/zmqpp.git
mkdir build
cd build 
cmake ..
make 
sudo make install

----
# 安装必备的包
$ sudo apt-get install libtool pkg-config build-essential autoconf automake
$ git clone https://github.com/zeromq/libzmq.git
$ mkdir build
$ cd build
$ cmake ..
$ sudo make -j4 install

# 安装libzmq的C++绑定

https://github.com/zeromq/zmqpp.git
#//$ git clone git@github.com:zeromq/cppzmq.git
$ mkdir build
$ cd build
$ cmake ..
$ sudo make -j4 install

1）基线校准的目录：

目前会对如下目录进行基线校准：当这些目录有任何#增删改#的动作的时候，
重启机器后会进行检查和重新覆盖。

linux:

/home/surgerii/apps
/home/surgerii/trolley
/home/surgerii/calibration

qnx:
/nfs/apps

2）需要临时修改目录内容如何办（比如调试）
为了避免新修改被覆盖，需要手工重新构建基线
linux:
~/apps/scripts/integrity.sh linux g

qnx:
ksh /nfs/apps/scripts/integrity.sh qnx g

3) 手工基线校准
linux：
~/apps/scripts/integrity.sh linux c
ksh /nfs/apps/scripts/integrity.sh qnx c

